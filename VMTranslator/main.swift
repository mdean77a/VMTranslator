//
//  main.swift
//  VMTranslator
//
//  Created by J Michael Dean on 5/17/23.
//
//  This is a console application that is NOT the same as a shell script containing Swift.
//  It is executable in any director, but has to be called as ./VMTranslator Filename.vm.
//  Many routines suggested in the text book are unnecessary because I utilized the stdio
//  conventions that make console applications attractive.

import Foundation

var parser = Parser()
var codeWriter = CodeWriter()

// This is used to assure unique labels in the code generated by the CodeWriter
// It is concatenated onto symbolic labels and iterated by an code generation that
// includes symbolic labels.  A cludge but it works.
var lineCounter = 0
var fileName = ""

enum CommandType {
    case C_ARITHMETIC, C_PUSH, C_POP, C_LABEL, C_GOTO, C_IF, C_FUNCTION, C_RETURN, C_CALL
}
// Do not need C_ARITHMETIC but here for completeness with textbook API.  For C_ARITHMETIC
// commands, the operand itself can be used as a selector in a switch statement.

func processFiles(){
    // Make sure that there is a file name or abort program
    if CommandLine.arguments.dropFirst().count == 0 {
        return
    }
    
    guard let sourceFile = freopen(CommandLine.arguments[1], "r", stdin) else {
        return
    }
    
    fileName = String(CommandLine.arguments[1].split(separator: ".").first!)
   
    guard let asmFile = freopen(CommandLine.arguments[1].split(separator: ".").first! + ".asm", "w", stdout) else {
        return
    }
    defer {
        fclose(sourceFile)
        fclose(asmFile)
    }
    
    while let line = readLine(){
        if let (commandType, segment, value) = parser.pushInstruction(line: line){
            // call Codewriter routine to handle push instruction
            print("// push \(segment) \(value) " )  // My comment line
            print(codeWriter.writePushPop(command:commandType, segment: segment, value: value) ?? "")
        }
        
        if let (commandType, segment, value) = parser.popInstruction(line: line){
            // call Codewriter routine to handle pop instruction
            print("// pop  " + segment + " " + value )  // My comment line
            print(codeWriter.writePushPop(command:commandType, segment: segment, value: value) ?? "")
        }
        
        if let (operand) = parser.arithmeticInstruction(line: line){
            // call Codewriter routine to handle arithmetic instruction
            print("// " + operand)  // My comment line
            print(codeWriter.writeArithmetic(operand: operand) ?? "")
        }
    }
}
processFiles()
