//
//  main.swift
//  VMTranslator
//
//  Created by J Michael Dean on 5/17/23.
//
//  This is a console application that is NOT the same as a shell script containing Swift.
//  It is executable in any director, but has to be called as ./VMTranslator Filename.vm.
//  Many routines suggested in the text book are unnecessary because I utilized the stdio
//  conventions that make console applications attractive.

import Foundation

var parser = Parser()
var codeWriter = CodeWriter()

// This is used to assure unique labels in the code generated by the CodeWriter
// It is concatenated onto symbolic labels and iterated by an code generation that
// includes symbolic labels.  A cludge but it works.
var lineCounter = 0
var fileName = ""

enum CommandType {
    case C_ARITHMETIC, C_PUSH, C_POP, C_LABEL, C_GOTO, C_IF, C_FUNCTION, C_RETURN, C_CALL
}

let operators: Set<String> = ["add","sub","neg","eq","gt","lt","and","or","not"]

// Do not need C_ARITHMETIC but here for completeness with textbook API.  For C_ARITHMETIC
// commands, the operand itself can be used as a selector in a switch statement.

func bootStrapCode() -> String {
    // This function will create the code to initialize the computer and will call the required program to start the game.
    //return("@Sys.init\n0;JMP\n")  THIS IS WRONG.  NEED TO CALL Sys.init, NOT GOTO Sys.init.
    return "// BOOTSTRAP WILL GO HERE"
}

//func endProgramInfiniteLoop() -> String {
//    return "\n(END)\n@END\n0;JMP"
//}

func openFiles(){
    if CommandLine.arguments.dropFirst().count == 0 {
        print("USAGE: You need to provide a vm filename or a directory containing vm files.")
        return
    }
    
    // Process the single vm file situation
    if CommandLine.arguments[1].split(separator: ".").last == "vm" {
        fileName = String(CommandLine.arguments[1].split(separator: ".").first!)
        guard let sourceFile = freopen(fileName + ".vm", "r", stdin) else {
            print("ERROR: Could not open the source file.")
            return
        }
        guard let asmFile = freopen(fileName + ".asm", "w", stdout)
        else {
            print("ERROR: Could not create target file.")
            return}
        //print(bootStrapCode())
        processFile(fileName:fileName)
        //print(endProgramInfiniteLoop())
        fclose(sourceFile)
        fclose(asmFile)
    }
    
    // Argument was not VM file.  Check to see if it is a directory and process:
    let url = URL(fileURLWithPath: CommandLine.arguments[1])
    if url.hasDirectoryPath {
        let directoryName = url.lastPathComponent
        let enumerator = FileManager.default.enumerator(atPath: url.lastPathComponent)
        let filePaths = enumerator?.allObjects as! [String]
        let vmFilePaths = filePaths.filter{$0.contains(".vm")}
        if vmFilePaths.isEmpty {
            print("ERROR: The directory contains no vm files.")
            return
        }
        // Create single target file with name of directory, INSIDE the directory.
        guard let asmFile = freopen(url.lastPathComponent + "/" + directoryName + ".asm", "w", stdout)
        else {
            print("ERROR: Could not create target file.")
            return}
        print(bootStrapCode())
        for vmFile in vmFilePaths{
            fileName = url.lastPathComponent + "/" + vmFile.split(separator: ".").first!
            guard let sourceFile = freopen(fileName + ".vm", "r", stdin) else {
                print("ERROR: Could not open the source file.")
                return
            }
            
            processFile(fileName: fileName)
            fclose(sourceFile)
        }
        //print(endProgramInfiniteLoop())
        fclose(asmFile)
    }
}


func processFile(fileName:String) {
    
    print("//  Assembly translation of \(fileName).vm")
    while let line = readLine(){
        
        // For each type of command, call the parser for a Regex to capture the parameters
        // and then call codeWriter to get the assembly code to emit.
        
        if let (commandType, segment, value) = parser.pushInstruction(line: line){
            print("// push \(segment) \(value) " )  // My comment line
            print(codeWriter.writePushPop(command:commandType, segment: segment, value: value) ?? "")
        }
        
        if let (commandType, segment, value) = parser.popInstruction(line: line){
            print("// pop  " + segment + " " + value )  // My comment line
            print(codeWriter.writePushPop(command:commandType, segment: segment, value: value) ?? "")
        }
        
        if let (operand) = parser.arithmeticInstruction(line: line){
            if operators.contains(operand) {
                print("// " + operand)  // My comment line
                print(codeWriter.writeArithmetic(operand: operand) ?? "")
            }
        }
        
        if let (label) = parser.labelInstruction(line: line){
            print("// label " + label)   // my comment line
            print(codeWriter.writeLabel(label:label) ?? "")
        }
        
        if let (gotoDestination) = parser.gotoInstruction(line: line){
            print("// goto " + gotoDestination)   // my comment line
            print(codeWriter.writeGoto(gotoDestination:gotoDestination) ?? "")
        }
        
        if let (gotoDestination) = parser.ifGotoInstruction(line: line){
            print("// if-goto " + gotoDestination)   // my comment line
            print(codeWriter.writeIfGoto(gotoDestination:gotoDestination) ?? "")
        }
        
        if let (functionName, nVars) = parser.functionInstruction(line: line){
            print("// function " + functionName + " " + nVars)   // my comment line
            print(codeWriter.writeFunction(functionName: functionName, nVars: nVars) ?? "")
        }
        
        if let  _ = parser.returnInstruction(line:line){
            print("// return")
            print(codeWriter.writeReturn() ?? "")
        }
        
        if let (functionName, nArgs) = parser.callInstruction(line: line) {
            print("// call " + functionName + " " + nArgs)
            print(codeWriter.writeCall(functionName: functionName, nArgs: nArgs) ?? "")
        }
    }
    
    return
}

openFiles()
